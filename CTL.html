<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Defect Transition Level Diagram</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f0f2f5;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .input-group { margin-bottom: 20px; }
        label { font-weight: bold; display: block; margin-bottom: 8px; color: #333; }
        textarea {
            width: 100%; height: 160px; font-family: monospace;
            padding: 12px; box-sizing: border-box; border: 1px solid #ccc;
            border-radius: 6px; background-color: #fafafa;
        }
        input[type="number"] {
            width: 150px; padding: 8px; border: 1px solid #ccc; border-radius: 6px;
        }
        button {
            padding: 12px 24px; font-size: 16px; cursor: pointer; font-weight: bold;
            background-color: #28a745; color: white; border: none;
            border-radius: 6px; transition: background-color 0.3s;
        }
        button:hover { background-color: #218838; }
        #plot { width: 100%; height: 600px; margin-top: 30px; }
        .help-text { font-size: 0.9em; color: #555; margin-bottom: 8px; line-height: 1.5; }
        .highlight { background-color: #e9ecef; padding: 2px 6px; border-radius: 4px; }
    </style>
</head>
<body>

    <div class="container">
        <h2>Defect Transition Levels</h2>
        
        <div class="input-group">
            <label for="bandgap">Band Gap (eV):</label>
            <input type="number" id="bandgap" value="3.0" step="0.1" min="0">
        </div>

        <div class="input-group">
            <label for="dataInput">Input Data:</label>
            <div class="help-text">
                For each line, write <span class="highlight"> energy at the VBM, charge state, and label</span>.<br>
                ※ JavaScript recognizes the text before the label's parentheses <code>()</code> and automatically groups defects of the same type. (Example: <code>Defect A</code>)
            </div>
            <textarea id="dataInput">
1.5, 1, Defect A (q=+1)
2.5, 0, Defect A (q=0)
4.5, -1, Defect A (q=-1)
0.8, 2, Defect B (q=+2)
3.2, -2, Defect B (q=-2)</textarea>
        </div>

        <button onclick="drawPlot()">Run!</button>

        <div id="plot"></div>
    </div>

    <script>
        function drawPlot() {
            const bandgap = parseFloat(document.getElementById('bandgap').value);
            const rawText = document.getElementById('dataInput').value.trim();
            const lines = rawText.split('\n');
            
            const groups = {};

            // 1. 데이터 파싱 및 결함 이름별로 그룹화
            lines.forEach(line => {
                if(!line.trim()) return;
                const parts = line.split(',');
                if(parts.length >= 3) {
                    const e0 = parseFloat(parts[0].trim());
                    const q = parseFloat(parts[1].trim());
                    const rawLabel = parts.slice(2).join(',').trim();
                    
                    // 괄호 앞부분을 추출하여 같은 결함끼리 묶음 (예: "Defect A (q=+1)" -> "Defect A")
                    let baseName = rawLabel.split('(')[0].trim();
                    if(!baseName) baseName = rawLabel;

                    if(!groups[baseName]) groups[baseName] = [];
                    groups[baseName].push({e0: e0, q: q, label: rawLabel});
                }
            });

            const traces = [];
            let xTickVals = [];
            let xTickText = [];
            let currentXIdx = 1;

            // 2. 각 결함 그룹별로 Lower Envelope (최저 에너지 상태) 교차점 계산
            for (let [defectName, defectLines] of Object.entries(groups)) {
                xTickVals.push(currentXIdx);
                xTickText.push(defectName);
                
                // q값 기준으로 중복 제거 (가장 낮은 e0만 유지)
                let qMap = new Map();
                for(let l of defectLines) {
                    if(!qMap.has(l.q) || qMap.get(l.q).e0 > l.e0) {
                        qMap.set(l.q, l);
                    }
                }
                let uniqueLines = Array.from(qMap.values());

                // E_F = 0 에서 가장 에너지가 낮은 상태 찾기 (동점일 경우 q가 가장 작은 것 선택)
                if (uniqueLines.length === 0) continue;
                let currentLine = uniqueLines[0];
                for(let l of uniqueLines) {
                    if(l.e0 < currentLine.e0) {
                        currentLine = l;
                    } else if (l.e0 === currentLine.e0 && l.q < currentLine.q) {
                        currentLine = l;
                    }
                }

                let transitions = [];
                let currentEf = 0; // x축 (Fermi Energy) 역할을 하는 변수

                // 교차점(Transition Level) 찾기 로직
                while(currentEf < bandgap) {
                    let nextEf = Infinity;
                    let nextLine = null;
                    
                    for(let l of uniqueLines) {
                        if(l.q >= currentLine.q) continue; // Lower envelope는 기울기(q)가 감소하는 방향으로만 진행됨
                        
                        // 두 직선의 교차점 (E_F 값)
                        let ef_intersect = (l.e0 - currentLine.e0) / (currentLine.q - l.q);
                        
                        if(ef_intersect > currentEf + 1e-5 && ef_intersect < nextEf) {
                            nextEf = ef_intersect;
                            nextLine = l;
                        }
                    }
                    
                    if(nextLine && nextEf <= bandgap) {
                        transitions.push({
                            ef: nextEf,
                            q1: currentLine.q,
                            q2: nextLine.q
                        });
                        currentEf = nextEf;
                        currentLine = nextLine;
                    } else {
                        break;
                    }
                }

                // 3. 계산된 Transition Level을 그래프의 작대기로 추가
                for(let t of transitions) {
                    // 수평 작대기 (Line)
                    traces.push({
                        x: [currentXIdx - 0.25, currentXIdx + 0.25],
                        y: [t.ef, t.ef],
                        mode: 'lines',
                        line: {color: '#d9534f', width: 4},
                        hovertemplate: `Transition Energy: %{y:.3f} eV<extra>${defectName} (${t.q1}/${t.q2})</extra>`,
                        showlegend: false
                    });
                    
                    // 텍스트 라벨 추가 (q1/q2)
                    traces.push({
                        x: [currentXIdx],
                        y: [t.ef],
                        mode: 'text',
                        text: [`(${t.q1}/${t.q2})`],
                        textposition: 'top center',
                        textfont: {size: 13, color: '#333'},
                        hoverinfo: 'skip',
                        showlegend: false
                    });
                }
                
                currentXIdx++;
            }

            // 4. 그래프 레이아웃 설정 (VBM, CBM 배경 포함)
            const layout = {
                title: '<b>Thermodynamic Transition Levels</b>',
                xaxis: { 
                    tickvals: xTickVals,
                    ticktext: xTickText,
                    range: [0.3, currentXIdx - 0.3], // x축 여백
                    showline: true, linewidth: 2, linecolor: '#333'
                },
                yaxis: { 
                    title: '<b>Fermi Energy (eV)</b>', 
                    range: [-0.3, bandgap + 0.3], // 위아래 여백 추가
                    zeroline: false, showline: true, linewidth: 2, linecolor: '#333'
                },
                shapes: [
                    // VBM 음영 영역 (y < 0)
                    {
                        type: 'rect', xref: 'paper', x0: 0, x1: 1, yref: 'y', y0: -10, y1: 0,
                        fillcolor: '#e2e8f0', line: {width: 0}, layer: 'below'
                    },
                    // CBM 음영 영역 (y > bandgap)
                    {
                        type: 'rect', xref: 'paper', x0: 0, x1: 1, yref: 'y', y0: bandgap, y1: bandgap + 10,
                        fillcolor: '#e2e8f0', line: {width: 0}, layer: 'below'
                    }
                ],
                annotations: [
                    // VBM, CBM 텍스트 라벨
                    { xref: 'paper', yref: 'y', x: 0.02, y: -0.15, text: '<b>VBM</b>', showarrow: false, font: {size: 14, color: '#555'} },
                    { xref: 'paper', yref: 'y', x: 0.02, y: bandgap + 0.15, text: '<b>CBM</b>', showarrow: false, font: {size: 14, color: '#555'} }
                ],
                template: 'plotly_white',
                hovermode: 'closest'
            };

            Plotly.newPlot('plot', traces, layout);
        }

        window.onload = drawPlot;
    </script>

</body>
</html>
